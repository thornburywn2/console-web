/**
 * Sessions API Routes
 * Manages session metadata, folders, tags, and organization
 */

import { Router } from 'express';
import { createLogger } from '../services/logger.js';
import { validateBody } from '../middleware/validate.js';
import {
  sessionMetadataUpdateSchema,
  sessionBulkActionSchema,
  sessionImportSchema,
  tagAssignmentsSchema,
} from '../validation/schemas.js';
import { sendSafeError } from '../utils/errorResponse.js';

const log = createLogger('sessions');

/**
 * Generate markdown format for session export
 */
function generateMarkdownExport(data) {
  const lines = [];

  lines.push(`# Session Export: ${data.session.displayName || data.session.sessionName}`);
  lines.push('');
  lines.push(`**Exported:** ${data.exportedAt}`);
  lines.push(`**From:** ${data.exportedFrom}`);
  lines.push(`**Export Version:** ${data.exportVersion}`);
  lines.push('');

  // Session info
  lines.push('## Session Information');
  lines.push('');
  lines.push(`- **Display Name:** ${data.session.displayName || 'N/A'}`);
  lines.push(`- **Session Name:** ${data.session.sessionName}`);
  lines.push(`- **Project:** ${data.session.projectName || 'N/A'}`);
  lines.push(`- **Project Path:** ${data.session.projectPath || 'N/A'}`);
  lines.push(`- **Working Directory:** ${data.session.workingDirectory || 'N/A'}`);
  lines.push(`- **Status:** ${data.session.status}`);
  lines.push(`- **Started:** ${data.session.startedAt}`);
  lines.push(`- **Last Active:** ${data.session.lastActiveAt}`);
  lines.push('');

  // Organization
  lines.push('## Organization');
  lines.push('');
  lines.push(`- **Folder:** ${data.organization.folder || 'None'}`);
  lines.push(`- **Tags:** ${data.organization.tags.map(t => t.name).join(', ') || 'None'}`);
  lines.push(`- **Pinned:** ${data.organization.isPinned ? 'Yes' : 'No'}`);
  lines.push('');

  // Notes
  if (data.context.notes.length > 0) {
    lines.push('## Notes');
    lines.push('');
    for (const note of data.context.notes) {
      lines.push(`### ${note.title || 'Untitled Note'}`);
      if (note.isPinned) lines.push('*Pinned*');
      lines.push(`*Created: ${note.createdAt}*`);
      lines.push('');
      lines.push(note.content);
      lines.push('');
    }
  }

  // Command history summary
  if (data.commandHistory.length > 0) {
    lines.push('## Command History');
    lines.push('');
    lines.push(`Total commands: ${data.commandHistory.length}`);
    lines.push('');
    lines.push('### Recent Commands (last 20)');
    lines.push('');
    lines.push('```bash');
    for (const cmd of data.commandHistory.slice(0, 20)) {
      lines.push(`# ${cmd.executedAt} (exit: ${cmd.exitCode ?? 'N/A'})`);
      lines.push(cmd.command);
    }
    lines.push('```');
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push('*Generated by Console.web*');

  return lines.join('\n');
}

export function createSessionsRouter(prisma) {
  const router = Router();

  /**
   * Get all sessions with folder and tag info
   */
  router.get('/', async (req, res) => {
    try {
      const { includeArchived = 'false', folderId, tagId } = req.query;

      const where = {};

      // Filter by archived status
      if (includeArchived !== 'true') {
        where.isArchived = false;
      }

      // Filter by folder
      if (folderId) {
        where.folderId = folderId;
      }

      // Filter by tag
      if (tagId) {
        where.tags = {
          some: { tagId }
        };
      }

      const sessions = await prisma.session.findMany({
        where,
        include: {
          folder: true,
          tags: {
            include: { tag: true }
          },
          notes: {
            orderBy: { createdAt: 'desc' },
            take: 1
          }
        },
        orderBy: [
          { isPinned: 'desc' },
          { lastAccessed: 'desc' }
        ]
      });

      res.json(sessions);
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to fetch sessions',
        operation: 'fetch sessions',
        requestId: req.id,
      });
    }
  });

  /**
   * Get a single session
   */
  router.get('/:id', async (req, res) => {
    try {
      const session = await prisma.session.findUnique({
        where: { id: req.params.id },
        include: {
          folder: true,
          tags: { include: { tag: true } },
          notes: { orderBy: { createdAt: 'desc' } }
        }
      });

      if (!session) {
        return res.status(404).json({ error: 'Session not found' });
      }

      res.json(session);
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to fetch session',
        operation: 'fetch session',
        requestId: req.id,
        context: { sessionId: req.params.id },
      });
    }
  });

  /**
   * Update session metadata
   */
  router.patch('/:id', validateBody(sessionMetadataUpdateSchema), async (req, res) => {
    try {
      const { displayName, folderId, isPinned, isTemporary } = req.body;

      const session = await prisma.session.update({
        where: { id: req.params.id },
        data: {
          ...(displayName !== undefined && { displayName }),
          ...(folderId !== undefined && { folderId }),
          ...(isPinned !== undefined && { isPinned }),
          ...(isTemporary !== undefined && { isTemporary })
        },
        include: {
          folder: true,
          tags: { include: { tag: true } }
        }
      });

      res.json(session);
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to update session',
        operation: 'update session',
        requestId: req.id,
        context: { sessionId: req.params.id },
      });
    }
  });

  /**
   * Pin/unpin a session
   */
  router.post('/:id/pin', async (req, res) => {
    try {
      const session = await prisma.session.findUnique({
        where: { id: req.params.id }
      });

      if (!session) {
        return res.status(404).json({ error: 'Session not found' });
      }

      const updated = await prisma.session.update({
        where: { id: req.params.id },
        data: { isPinned: !session.isPinned }
      });

      res.json(updated);
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to toggle pin',
        operation: 'toggle session pin',
        requestId: req.id,
        context: { sessionId: req.params.id },
      });
    }
  });

  /**
   * Archive a session
   */
  router.post('/:id/archive', async (req, res) => {
    try {
      const session = await prisma.session.update({
        where: { id: req.params.id },
        data: {
          isArchived: true,
          archivedAt: new Date()
        }
      });

      res.json(session);
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to archive session',
        operation: 'archive session',
        requestId: req.id,
        context: { sessionId: req.params.id },
      });
    }
  });

  /**
   * Restore an archived session
   */
  router.post('/:id/restore', async (req, res) => {
    try {
      const session = await prisma.session.update({
        where: { id: req.params.id },
        data: {
          isArchived: false,
          archivedAt: null
        }
      });

      res.json(session);
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to restore session',
        operation: 'restore session',
        requestId: req.id,
        context: { sessionId: req.params.id },
      });
    }
  });

  /**
   * Add tags to a session
   */
  router.post('/:id/tags', validateBody(tagAssignmentsSchema), async (req, res) => {
    try {
      const { tagIds } = req.validatedBody;

      // Create tag assignments
      await prisma.sessionTagAssignment.createMany({
        data: tagIds.map(tagId => ({
          sessionId: req.params.id,
          tagId
        })),
        skipDuplicates: true
      });

      const session = await prisma.session.findUnique({
        where: { id: req.params.id },
        include: {
          tags: { include: { tag: true } }
        }
      });

      res.json(session);
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to add tags',
        operation: 'add tags to session',
        requestId: req.id,
        context: { sessionId: req.params.id },
      });
    }
  });

  /**
   * Remove a tag from a session
   */
  router.delete('/:id/tags/:tagId', async (req, res) => {
    try {
      await prisma.sessionTagAssignment.deleteMany({
        where: {
          sessionId: req.params.id,
          tagId: req.params.tagId
        }
      });

      const session = await prisma.session.findUnique({
        where: { id: req.params.id },
        include: {
          tags: { include: { tag: true } }
        }
      });

      res.json(session);
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to remove tag',
        operation: 'remove tag from session',
        requestId: req.id,
        context: { sessionId: req.params.id, tagId: req.params.tagId },
      });
    }
  });

  /**
   * Bulk actions on sessions
   */
  router.post('/bulk', validateBody(sessionBulkActionSchema), async (req, res) => {
    try {
      const { sessionIds, action, folderId } = req.validatedBody;

      let result;

      switch (action) {
        case 'pin':
          result = await prisma.session.updateMany({
            where: { id: { in: sessionIds } },
            data: { isPinned: true }
          });
          break;

        case 'unpin':
          result = await prisma.session.updateMany({
            where: { id: { in: sessionIds } },
            data: { isPinned: false }
          });
          break;

        case 'archive':
          result = await prisma.session.updateMany({
            where: { id: { in: sessionIds } },
            data: { isArchived: true, archivedAt: new Date() }
          });
          break;

        case 'restore':
          result = await prisma.session.updateMany({
            where: { id: { in: sessionIds } },
            data: { isArchived: false, archivedAt: null }
          });
          break;

        case 'move':
          if (!folderId) {
            return res.status(400).json({ error: 'folderId required for move action' });
          }
          result = await prisma.session.updateMany({
            where: { id: { in: sessionIds } },
            data: { folderId }
          });
          break;

        case 'addTag': {
          const { tagId } = req.validatedBody;
          if (!tagId) {
            return res.status(400).json({ error: 'tagId required for addTag action' });
          }
          result = await prisma.sessionTagAssignment.createMany({
            data: sessionIds.map(sessionId => ({
              sessionId,
              tagId
            })),
            skipDuplicates: true
          });
          break;
        }

        case 'delete':
          result = await prisma.session.deleteMany({
            where: { id: { in: sessionIds } }
          });
          break;

        default:
          return res.status(400).json({ error: `Unknown action: ${action}` });
      }

      res.json({ success: true, affected: result.count });
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to perform bulk action',
        operation: 'bulk session action',
        requestId: req.id,
      });
    }
  });

  /**
   * Export session memory/context as JSON
   * Includes: metadata, command history, notes, tags, terminal state
   */
  router.get('/:id/export', async (req, res) => {
    try {
      const { format = 'json' } = req.query;

      const session = await prisma.session.findUnique({
        where: { id: req.params.id },
        include: {
          project: {
            select: { name: true, path: true }
          },
          folder: true,
          tags: {
            include: { tag: true }
          },
          notes: {
            orderBy: { createdAt: 'desc' }
          },
          commandHistory: {
            orderBy: { executedAt: 'desc' },
            take: 500 // Last 500 commands
          }
        }
      });

      if (!session) {
        return res.status(404).json({ error: 'Session not found' });
      }

      const exportData = {
        exportVersion: '1.0',
        exportedAt: new Date().toISOString(),
        exportedFrom: 'Console.web',
        session: {
          displayName: session.displayName,
          sessionName: session.sessionName,
          projectName: session.project?.name,
          projectPath: session.project?.path,
          workingDirectory: session.workingDirectory,
          startedAt: session.startedAt,
          lastActiveAt: session.lastActiveAt,
          status: session.status
        },
        organization: {
          folder: session.folder?.name || null,
          folderColor: session.folder?.color || null,
          tags: session.tags.map(t => ({
            name: t.tag.name,
            color: t.tag.color
          })),
          isPinned: session.isPinned
        },
        context: {
          notes: session.notes.map(n => ({
            title: n.title,
            content: n.content,
            isPinned: n.isPinned,
            createdAt: n.createdAt
          })),
          terminalState: {
            scrollbackBuffer: session.scrollbackBuffer,
            cursorPosition: session.cursorPosition,
            terminalSize: session.terminalSize
          }
        },
        commandHistory: session.commandHistory.map(cmd => ({
          command: cmd.command,
          output: cmd.output,
          exitCode: cmd.exitCode,
          executedAt: cmd.executedAt,
          duration: cmd.duration
        }))
      };

      if (format === 'markdown') {
        // Generate markdown format
        const md = generateMarkdownExport(exportData);
        res.setHeader('Content-Type', 'text/markdown');
        res.setHeader('Content-Disposition', `attachment; filename="session-${session.sessionName}-export.md"`);
        return res.send(md);
      }

      // Default JSON format
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename="session-${session.sessionName}-export.json"`);
      res.json(exportData);
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to export session',
        operation: 'export session',
        requestId: req.id,
        context: { sessionId: req.params.id },
      });
    }
  });

  /**
   * Import session from exported JSON
   * Creates a new session with imported data
   */
  router.post('/import', validateBody(sessionImportSchema), async (req, res) => {
    try {
      const { exportData, targetProjectId, createNotes, importHistory } = req.validatedBody;

      // Verify target project exists
      const project = await prisma.project.findUnique({
        where: { id: targetProjectId }
      });

      if (!project) {
        return res.status(404).json({ error: 'Target project not found' });
      }

      // Create unique session name
      const baseName = exportData.session.displayName || exportData.session.sessionName || 'imported';
      const sessionName = `${baseName}-import-${Date.now()}`;

      // Find or create folder if specified
      let folderId = null;
      if (exportData.organization?.folder) {
        const folder = await prisma.sessionFolder.findFirst({
          where: { name: exportData.organization.folder }
        });
        if (folder) {
          folderId = folder.id;
        }
      }

      // Create the session
      const newSession = await prisma.session.create({
        data: {
          projectId: targetProjectId,
          sessionName,
          displayName: `${exportData.session.displayName || 'Imported'} (from export)`,
          folderId,
          isPinned: false,
          isTemporary: false,
          isArchived: false,
          status: 'ACTIVE',
          workingDirectory: project.path
        }
      });

      // Import notes if requested
      if (createNotes && exportData.context?.notes?.length > 0) {
        await prisma.sessionNote.createMany({
          data: exportData.context.notes.map(note => ({
            sessionId: newSession.id,
            title: note.title || 'Imported Note',
            content: note.content,
            isPinned: note.isPinned || false
          }))
        });
      }

      // Create import summary note
      const summaryNote = `## Session Import Summary

**Imported from:** ${exportData.exportedFrom || 'Unknown'}
**Export date:** ${exportData.exportedAt || 'Unknown'}
**Original project:** ${exportData.session.projectName || 'Unknown'}
**Original session:** ${exportData.session.sessionName || 'Unknown'}

### Imported Data
- Notes: ${exportData.context?.notes?.length || 0}
- Command history entries: ${importHistory ? (exportData.commandHistory?.length || 0) : 'Not imported'}
- Tags: ${exportData.organization?.tags?.map(t => t.name).join(', ') || 'None'}

### Original Context
${exportData.context?.notes?.map(n => `- ${n.title || 'Note'}: ${n.content.substring(0, 100)}...`).join('\n') || 'No notes'}
`;

      await prisma.sessionNote.create({
        data: {
          sessionId: newSession.id,
          title: 'Import Summary',
          content: summaryNote,
          isPinned: true
        }
      });

      // Import command history if requested (limited to last 100)
      if (importHistory && exportData.commandHistory?.length > 0) {
        const historyToImport = exportData.commandHistory.slice(0, 100);
        await prisma.commandHistory.createMany({
          data: historyToImport.map(cmd => ({
            sessionId: newSession.id,
            command: cmd.command,
            output: cmd.output,
            exitCode: cmd.exitCode,
            duration: cmd.duration
          }))
        });
      }

      // Find and assign matching tags
      if (exportData.organization?.tags?.length > 0) {
        for (const tagData of exportData.organization.tags) {
          const existingTag = await prisma.sessionTag.findFirst({
            where: { name: tagData.name }
          });
          if (existingTag) {
            await prisma.sessionTagAssignment.create({
              data: {
                sessionId: newSession.id,
                tagId: existingTag.id
              }
            });
          }
        }
      }

      // Fetch complete session with relations
      const completeSession = await prisma.session.findUnique({
        where: { id: newSession.id },
        include: {
          folder: true,
          tags: { include: { tag: true } },
          notes: { orderBy: { createdAt: 'desc' } }
        }
      });

      res.status(201).json({
        success: true,
        session: completeSession,
        imported: {
          notes: exportData.context?.notes?.length || 0,
          commands: importHistory ? Math.min(exportData.commandHistory?.length || 0, 100) : 0,
          tags: exportData.organization?.tags?.length || 0
        }
      });
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to import session',
        operation: 'import session',
        requestId: req.id,
      });
    }
  });

  /**
   * Fork a session (create copy)
   */
  router.post('/:id/fork', async (req, res) => {
    try {
      const original = await prisma.session.findUnique({
        where: { id: req.params.id },
        include: {
          tags: true,
          notes: true
        }
      });

      if (!original) {
        return res.status(404).json({ error: 'Session not found' });
      }

      const forked = await prisma.session.create({
        data: {
          projectPath: original.projectPath,
          displayName: `${original.displayName || original.sessionName} (Fork)`,
          sessionName: `${original.sessionName}-fork-${Date.now()}`,
          folderId: original.folderId,
          isPinned: false,
          isTemporary: false,
          isArchived: false,
          tags: {
            create: original.tags.map(t => ({ tagId: t.tagId }))
          }
        },
        include: {
          folder: true,
          tags: { include: { tag: true } }
        }
      });

      res.status(201).json(forked);
    } catch (error) {
      return sendSafeError(res, error, {
        userMessage: 'Failed to fork session',
        operation: 'fork session',
        requestId: req.id,
        context: { sessionId: req.params.id },
      });
    }
  });

  return router;
}
